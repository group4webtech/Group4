import pandas as pd
import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
from bokeh.io import show, output_notebook
from bokeh.models import Plot, Range1d, MultiLine, Circle, HoverTool, TapTool, BoxSelectTool, WheelZoomTool, ResetTool, PanTool, SaveTool, BoxSelectTool, LassoSelectTool
from bokeh.models.graphs import from_networkx, NodesAndLinkedEdges, EdgesAndLinkedNodes
from bokeh.models.sources import ColumnDataSource, CDSView
from bokeh.models.widgets import Tabs, Panel
from bokeh.palettes import Spectral4, Spectral8
from bokeh.plotting import figure, output_file, show
from bokeh.palettes import Spectral8
from math import sqrt
import itertools

output_file('force_directed.html')
#plt.show()

separator = ";"
filename = 'DBL'
fileext = '.csv'

# removes quotation marks at the end and start of each line (if necessary)
with open(filename + fileext, 'r') as r, open(filename + '_01' + fileext, 'w') as w:
    for num, line in enumerate(r):
        if num >= 0:
            if line[0] == "\"" and line[-1] == "\"":
                newline = line[1:-1]
            elif line[0] == "\"" and line[-1] == "\n" and line[-2] == "\"":
                newline = line[1:-2] + "\n"
            else:
                newline = line
        else:
            newline = line
        w.write(newline)

# removes the first coma at the beginning of each line (if necessary)
with open(filename + '_01' + fileext, 'r') as r, open(filename + '_02' + fileext, 'w') as w:
    for num, line in enumerate(r):
        if num >= 0:
            if line[0] == separator:
                newline = line[1:]
            else:
                newline = line
        else:
            newline = line
        w.write(newline)

# removes comas at the end of each line (if necessary)
with open(filename + '_02' + fileext, 'r') as r, open(filename + '_03' + fileext, 'w') as w:
    for num, line in enumerate(r):
        if num >= 0:
            if line[-1] == separator:
                newline = line[:-1]
            elif line[-1] == "\n" and line[-2] == separator:
                newline = line[:-2] + "\n"
            else:
                newline = line
        else:
            newline = line
        # removes all "_" in the names of the people and replaves them by " " (spacebar)
        newline = newline.replace("_", " ")
        w.write(newline)

df = pd.read_csv(filename + '_03' + fileext, sep=separator)     # full csv file with 1053x1053 values

# get original column names from df
list_columns_names = df.columns

# change the column labels from strings to integers
list_columns_int = []

for number in range(0, len(df.index.values)):
    list_columns_int.append(number)

df.columns = list_columns_int

# change the rows labels/ indexes from strings to integers
df['index'] = list_columns_int
df.set_index("index", inplace=True)

#take 5 nodes
df_ex = df[0:100]




# Create an example graph
g=nx.DiGraph()

# add nodes and edges to the graph
weights = []

for row in df.index.values:
    for column in df.index.values:
        if  row < column:
            if (df[row][column] > 0):
                g.add_edge(row,column, weight=df[row][column])
                weights.append(df[row][column])
            else:
                 g.add_node(row)

#list_columns_names

colors = []
for n in weights:
    colors.append(10000 / n)

# create a dictoinary with double for loop
mapping = {old_label:new_label for old_label, new_label in itertools.zip_longest(sorted(g.nodes()), list_columns_names, fillvalue=1)}
#print(mapping)

# create a dictionary with zip()
#dictionary = dict(zip(list_columns_int, list_columns_names))
#print(dictionary)

# relabel the names of the nodes from integers back to strings
nx.relabel_nodes(g, mapping, copy=False)

plt.figure(figsize=(20,10))

pos=nx.fruchterman_reingold_layout(g)


r = 1.8*(max(g.degree())[1])/sqrt(g.number_of_nodes())

ly = nx.fruchterman_reingold_layout(g,k=r, iterations=50, pos=nx.fruchterman_reingold_layout(g))


plotwidth = 715                                       # PLOT WIDTH AND PLOT HEIGHT #
plotheight = 715


N = g.number_of_nodes()
x = np.random.random(size=N) * 100  # creates an array of size = N with random numbers from 0 ... 100.
y = np.random.random(size=N) * 100  # creates an array of size = N with random numbers from 0 ... 100.
#radii = np.random.random(size=N) * 1.5
colors = [ "#%02x%02x%02x" % (int(r), int(g), 150) for r, g in zip(50+2*x, 30+2*y) ] # creates colours RGB with values R = 50 ... 255, G = 30 .. 230, B = 150.

#nx.draw(g, pos=ly, nodelist=d.keys(),  node_color='blue', edgelist=g.edges(), edge_color=weights, arrowsize=20, with_labels=False, node_size=[v * 10 for v in d.values()], width=2.0, edge_cmap=plt.cm.Reds)

# plotting

# force directed layout
plot_fd = Plot(plot_width=plotwidth, plot_height=plotheight,
            x_range=Range1d(-1.1, 1.1), y_range=Range1d(-1.1, 1.1))

graph_fd = from_networkx(g, nx.fruchterman_reingold_layout(g,k=r, iterations=100, pos=nx.fruchterman_reingold_layout(g), scale=1, center=(0,0)))

#posxy=nx.fruchterman_reingold_layout(g)
#for i in range(len(posxy()):
#    posxy


# !!! Specify colors with node attributes !!!
graph_fd.node_renderer.data_source.data['degree'] = list(zip(*g.degree))[1]
graph_fd.node_renderer.data_source.data['degree2'] = [x+1 for x in graph_fd.node_renderer.data_source.data['degree']]
graph_fd.node_renderer.data_source.data['my_fill_color'] = colors

graph_fd.node_renderer.glyph = Circle(size ="degree2",  fill_color='my_fill_color', fill_alpha=0.85)
graph_fd.node_renderer.selection_glyph = Circle(size=15, fill_color='red', fill_alpha=0.5)
graph_fd.node_renderer.hover_glyph = Circle(size=15, fill_color='green', fill_alpha=0.5)


#graph_circle.node_renderer.data_source.data['colors'] = Spectral8

graph_fd.edge_renderer.glyph = MultiLine(line_color='blue', line_alpha=0.5, line_width=3)
graph_fd.edge_renderer.selection_glyph = MultiLine(line_color='red', line_width=4)
graph_fd.edge_renderer.hover_glyph = MultiLine(line_color='green', line_width=4)
graph_fd.edge_renderer.data_source.data['weight'] = weights
graph_fd.edge_renderer.glyph.line_width = {'field': 'weight'}
graph_fd.edge_renderer.data_source.data['color'] =  colors
#graph_circle.edge_renderer.glyph.line_color = {'field': 'color'}

graph_fd.selection_policy = NodesAndLinkedEdges()
graph_fd.inspection_policy = NodesAndLinkedEdges()

# !!! Hover the node attributes !!!
node_hover = HoverTool(tooltips=[('Name', '@index'), ('Degree', '@degree')])

plot_fd.add_tools(node_hover)
plot_fd.add_tools(WheelZoomTool())
plot_fd.add_tools(ResetTool())
plot_fd.add_tools(PanTool())
plot_fd.add_tools(TapTool())
plot_fd.add_tools(SaveTool())
plot_fd.add_tools(BoxSelectTool())
plot_fd.add_tools(LassoSelectTool())

plot_fd.renderers.append(graph_fd)

#output_notebook()
#show(plot)

# Put the legend in the upper left corner
#plot_spring.legend.location = 'top_left'

# Organize the layout

# Create two panels, one for each conference
fd_panel = Panel(child=plot_fd, title='Force Directed layout')

# Assign the panels to Tabs
tabs = Tabs(tabs=[fd_panel])

# Preview and save
#show(fig)
#show(fig1)

# Show the tabbed layout
show(tabs)
